---
title: "Running A Docker container"
description: "This article covers how to run a container, expose it to the outside world, access a running container and access the logs of a container"
date: "2022-09-07"
banner:
  src: "../../images/lucas-hoang-RJPEfLuv6Ao-unsplash.jpg"
  alt: "Container"
  caption: 'Photo by <u><a href="https://unsplash.com/photos/RJPEfLuv6Ao">Lucas Hoang</a></u>'
categories:
  - "Docker"
keywords:
  - "Container name"
  - "Container port"
  - "Logs"
---

# Options to docker run command

Under normal circumstances, when a docker container starts, it will run the process inside the container and once that process is done then it stops. In case we would like the container to keep running, we need to use the docker **"-d"** flag. This will detach the container in order to keep it running in the background.

The command below will run the container from the debian image in detached mode **"-d"**. The **"it"** flag allows a shell prompt to be available so we can interact with the container.

```docker
docker run -dit debian
```

See the output below

```
user@node:~$ docker run -dit debian
395afd35b292410ea9a64b42d1af812c14268154eeae1c08ae078c8b3546a795

user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
395afd35b292   debian    "bash"    4 seconds ago   Up 3 seconds             amazing_hawking
```

<br>

# Give a name to a container

Just like we can access a node using its IP address, a container can be accessed via its hash number. 

From the output above, the hash number or ID of the container that was created is *395afd35b292410ea9a64b42d1af812c14268154eeae1c08ae078c8b3546a795*.

This is not very user friendly. We can give a *"user friendly name"* to a container in order to access it easily. 

The command below give the name "**web**" to the container.

```docker
docker run -dit --name=web debian
```

After running the command we will also run a **"docker ps"** command to display the containers that are currently running on the host.

```
user@node:~$ docker run -dit --name=web debian
d7e214a6ba61663879a3ae2619e7596ed6400901b42e20816c719711352de4d0

user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
d7e214a6ba61   debian    "bash"    8 seconds ago   Up 7 seconds             web
395afd35b292   debian    "bash"    8 minutes ago   Up 8 minutes             amazing_hawking
```

The output shows us the container we previously created with a name **"amazing_hawking"**. When a name is not provided in the docker run command, docker randomly generates a name for the container. **"amazing_hawking"** is the random name generated by Docker for the container we previously created.
The other container name is **"web"** which is the name we provided in the docker command.

<u>Note:</u> When running **docker run** with --name flag, we don't have to specify "=" between the name flag and the value we want to provide as a name. 

The following command with just a space will also work.

```docker
docker run -dit --name another_web debian
```

See the output below

```
user@node:~$ docker run -dit --name another_web debian
0a0d61c6d21e064d3be10f52a38d3c16ebd6c8d72d44206f6a5454dc2236d7ef

user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES
0a0d61c6d21e   debian    "bash"    3 seconds ago    Up 2 seconds              another_web
d7e214a6ba61   debian    "bash"    10 minutes ago   Up 10 minutes             web
395afd35b292   debian    "bash"    18 minutes ago   Up 18 minutes             amazing_hawking
```
<br>

# View all containers (running or stopped)

The command below shows all containers

```docker
docker ps -a
```
The output below shows the result of the command with all the containers with their ID, image, command, created date, status, port and names.

```
user@node:~$ docker ps -a
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS                    PORTS     NAMES
0a0d61c6d21e   debian         "bash"                   About a minute ago   Up About a minute                   another_web
d7e214a6ba61   debian         "bash"                   12 minutes ago       Up 12 minutes                       web
395afd35b292   debian         "bash"                   20 minutes ago       Up 20 minutes                       amazing_hawking
52578dbdfbd4   redis          "docker-entrypoint.s…"   24 hours ago         Exited (0) 23 hours ago             exec_command_redis
d95f541f5ab1   redis          "docker-entrypoint.s…"   24 hours ago         Exited (0) 24 hours ago             enter_redis
3cd567d1d673   httpd:latest   "httpd-foreground"       25 hours ago         Exited (0) 23 hours ago             apache_welcome
51962f63eda2   redis          "docker-entrypoint.s…"   46 hours ago         Exited (0) 46 hours ago             hopeful_meitner
```

The status column shows us whether the container is still running or not.

In order to see the latest container that has been created regarless of its status (running or stopped) we run the following command:

```docker
docker ps -l
```

See the output below

```
user@node:~$ docker ps -l
CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
0a0d61c6d21e   debian    "bash"    6 minutes ago   Up 6 minutes             another_web
```

Once a name is given to container, we cannot create another container with the same name. See the ouput returned when we tried to create another container with the name **web**.

```
user@node:~$ docker run -dit --name web debian
docker: Error response from daemon: Conflict. The container name "/web" is already in use by container "d7e214a6ba61663879a3ae2619e7596ed6400901b42e20816c719711352de4d0". You have to remove (or rename) that container to be able to reuse that name.
See 'docker run --help'.
```

Docker provides a command to remove a container. It is good practice to stop the container before removing it.

We will stop and remove the **web** container with the commands below:

```docker
docker stop web
```

```docker
docker rm web
```

As we can see output below the web container is completly gone.

```
user@node:~$ docker stop web
web
user@node:~$ docker rm web
web
user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES
0a0d61c6d21e   debian    "bash"    17 minutes ago   Up 17 minutes             another_web
395afd35b292   debian    "bash"    35 minutes ago   Up 35 minutes             amazing_hawking
user@node:~$ docker ps -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                    PORTS     NAMES
0a0d61c6d21e   debian         "bash"                   17 minutes ago   Up 17 minutes                       another_web
395afd35b292   debian         "bash"                   36 minutes ago   Up 36 minutes                       amazing_hawking
52578dbdfbd4   redis          "docker-entrypoint.s…"   24 hours ago     Exited (0) 23 hours ago             exec_command_redis
d95f541f5ab1   redis          "docker-entrypoint.s…"   24 hours ago     Exited (0) 24 hours ago             enter_redis
3cd567d1d673   httpd:latest   "httpd-foreground"       25 hours ago     Exited (0) 23 hours ago             apache_welcome
51962f63eda2   redis          "docker-entrypoint.s…"   47 hours ago     Exited (0) 46 hours ago             hopeful_meitner
```

<br>

# Configure a container to restart on failure

There are instances where a container could stop due to failure or due to the host computer getting rebooted.
In case we want a container to restart anytime this type of failure occurs, we can run the following command:

```docker
docker run -dit --restart=always --name=my_container debian
```

```
user@node:~$ docker run -dit --restart=always --name=my_container debian
a123ea82b713c93cfc68b288a2f07172522cef5b31f44b436259590c843c0db5
user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES
a123ea82b713   debian    "bash"    5 seconds ago    Up 4 seconds              my_container
0a0d61c6d21e   debian    "bash"    24 minutes ago   Up 24 minutes             another_web
395afd35b292   debian    "bash"    43 minutes ago   Up 43 minutes             amazing_hawking
```

We can use the command below to check the restart policy. 

```docker
docker inspect my_container | grep -A3 RestartPolicy
```

The "grep -A3 RestartPolicy" looks RestartPolicy and the next 3 lines after it.
The result below shows that the restart policy is set to "Always".

```
user@node:~$ docker inspect my_container | grep -A3 RestartPolicy
            "RestartPolicy": {
                "Name": "always",
                "MaximumRetryCount": 0
            },
```

<br>

# Expose a container to the public network

When an application is running in a docker container, it is not accessible to the outside world. In order to make it accessible, we need to provide a port on which the outside world can access the application and also the port on which the application will be available within the container.

This command with the **-p** flag will help provide outside and inside port: 

docker run -dit **-p** <**outside_port**>:<**inside_port**>

```docker
docker run --name public_container -d -p 8080:80 httpd
```

The output below shows the container running on port 80. When we run a curl command on http://localhost:8080 we can get an output from the application running in the container.


```
user@node:~$ docker run --name public_container -d -p 8080:80 httpd
9a741e4b32d88e1b7a9f31055850c71493e8615a3e5edddb4e3aa30a8a584ee2

user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND              CREATED          STATUS          PORTS                  NAMES
9a741e4b32d8   httpd     "httpd-foreground"   16 seconds ago   Up 14 seconds   0.0.0.0:8080->80/tcp   public_container
a123ea82b713   debian    "bash"               13 minutes ago   Up 13 minutes                          my_container
0a0d61c6d21e   debian    "bash"               38 minutes ago   Up 38 minutes                          another_web
395afd35b292   debian    "bash"               57 minutes ago   Up 57 minutes                          amazing_hawking

user@node:~$ curl http://localhost:8080
<html><body><h1>It works!</h1></body></html>
```

<br>

# Connect to a running container using interactive shell

The command below will start a container with the prompt available to the user.

```docker
docker run -it --name apache httpd /bin/bash
```

**/bin/bash** will run when the container starts and allows the user to run bash commands in the container.

To exit the container, we can type **"ctrl+D"** or type **"exit"**. This takes us back to the host.

However when we run the docker ps command, we see that the container is no longer running. That is because when we exited the container, it stopped altogether.

```
user@node:~$ docker run -it --name apache httpd /bin/bash
root@0a2a26f49ac6:/usr/local/apache2# ls
bin  build  cgi-bin  conf  error  htdocs  icons  include  logs  modules
root@0a2a26f49ac6:/usr/local/apache2# ls ltr
ls: cannot access 'ltr': No such file or directory
root@0a2a26f49ac6:/usr/local/apache2# ls -ltr
total 40
drwxr-xr-x 2 root root 4096 Aug 23 03:32 modules
drwxr-xr-x 2 root root 4096 Aug 23 03:32 logs
drwxr-xr-x 3 root root 4096 Aug 23 03:32 icons
drwxr-xr-x 2 root root 4096 Aug 23 03:32 htdocs
drwxr-xr-x 3 root root 4096 Aug 23 03:32 error
drwxr-xr-x 2 root root 4096 Aug 23 03:32 cgi-bin
drwxr-xr-x 2 root root 4096 Aug 23 03:32 include
drwxr-xr-x 4 root root 4096 Aug 23 03:32 conf
drwxr-xr-x 2 root root 4096 Aug 23 03:32 build
drwxr-xr-x 2 root root 4096 Aug 23 03:32 bin
root@0a2a26f49ac6:/usr/local/apache2# exit
exit

user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND              CREATED             STATUS             PORTS                  NAMES
9a741e4b32d8   httpd     "httpd-foreground"   23 minutes ago      Up 23 minutes      0.0.0.0:8080->80/tcp   public_container
a123ea82b713   debian    "bash"               36 minutes ago      Up 36 minutes                             my_container
0a0d61c6d21e   debian    "bash"               About an hour ago   Up About an hour                          another_web
395afd35b292   debian    "bash"               About an hour ago   Up About an hour                          amazing_hawkin
```

Let's run the following command to start another container

```
docker run -dit --name second_apache httpd /bin/bash
```

Since we used **-d**, docker detaches the container when it starts.

```
user@node:~$ docker run -dit --name second_apache httpd /bin/bash
cc15d8652ca23eb5c1b87fb5f317873f3696cc6d6eeece4da3cfad5d672538b4

user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND              CREATED             STATUS             PORTS                  NAMES
cc15d8652ca2   httpd     "/bin/bash"          9 seconds ago       Up 8 seconds       80/tcp                 second_apache
9a741e4b32d8   httpd     "httpd-foreground"   26 minutes ago      Up 26 minutes      0.0.0.0:8080->80/tcp   public_container
a123ea82b713   debian    "bash"               40 minutes ago      Up 40 minutes                             my_container
0a0d61c6d21e   debian    "bash"               About an hour ago   Up About an hour                          another_web
395afd35b292   debian    "bash"               About an hour ago   Up About an hour                          amazing_hawking
```

The command below allows to run bash commands interactively in the container

```docker
docker exec -it second_apache /bin/bash
```

The output below shows that after starting the container with **-d** flag we can access it and run some commands in it. 
After we exit the bash prompt from the container, it is still available.

```
user@node:~$ docker run -dit --name second_apache httpd /bin/bash
cc15d8652ca23eb5c1b87fb5f317873f3696cc6d6eeece4da3cfad5d672538b4
user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND              CREATED             STATUS             PORTS                  NAMES
cc15d8652ca2   httpd     "/bin/bash"          9 seconds ago       Up 8 seconds       80/tcp                 second_apache
9a741e4b32d8   httpd     "httpd-foreground"   26 minutes ago      Up 26 minutes      0.0.0.0:8080->80/tcp   public_container
a123ea82b713   debian    "bash"               40 minutes ago      Up 40 minutes                             my_container
0a0d61c6d21e   debian    "bash"               About an hour ago   Up About an hour                          another_web
395afd35b292   debian    "bash"               About an hour ago   Up About an hour                          amazing_hawking

user@node:~$ docker exec -it second_apache /bin/bash

root@cc15d8652ca2:/usr/local/apache2# ls -ltr
total 40
drwxr-xr-x 2 root root 4096 Aug 23 03:32 modules
drwxr-xr-x 2 root root 4096 Aug 23 03:32 logs
drwxr-xr-x 3 root root 4096 Aug 23 03:32 icons
drwxr-xr-x 2 root root 4096 Aug 23 03:32 htdocs
drwxr-xr-x 3 root root 4096 Aug 23 03:32 error
drwxr-xr-x 2 root root 4096 Aug 23 03:32 cgi-bin
drwxr-xr-x 2 root root 4096 Aug 23 03:32 include
drwxr-xr-x 4 root root 4096 Aug 23 03:32 conf
drwxr-xr-x 2 root root 4096 Aug 23 03:32 build
drwxr-xr-x 2 root root 4096 Aug 23 03:32 bin
root@cc15d8652ca2:/usr/local/apache2#
exit

user@node:~$ docker ps
CONTAINER ID   IMAGE     COMMAND              CREATED             STATUS             PORTS                  NAMES
cc15d8652ca2   httpd     "/bin/bash"          4 minutes ago       Up 4 minutes       80/tcp                 second_apache
9a741e4b32d8   httpd     "httpd-foreground"   31 minutes ago      Up 31 minutes      0.0.0.0:8080->80/tcp   public_container
a123ea82b713   debian    "bash"               45 minutes ago      Up 45 minutes                             my_container
0a0d61c6d21e   debian    "bash"               About an hour ago   Up About an hour                          another_web
395afd35b292   debian    "bash"               About an hour ago   Up About an hour                          amazing_hawking
```


we can also use **docker exec -it second_apache sh**. This will start shell instead of bash.

The **"exec"** docker command can also be used to run quick commands in the container.

For instance, the command below will create a file name "hello" under the root folder

```docker
docker exec -d second_apache touch /root/hello
```

In order to confirm that the file was created, we can use the exec command to access the container and check whether the file was created under the root folder:

```
user@node:~$ docker exec -d second_apache touch /root/hello

user@node:~$ docker exec -it second_apache bash

root@cc15d8652ca2:/usr/local/apache2# ls
bin  build  cgi-bin  conf  error  htdocs  icons  include  logs  modules
root@cc15d8652ca2:/usr/local/apache2# ls /root
hello
root@cc15d8652ca2:/usr/local/apache2#
exit
```

In case we don't want to access the prompt of the container but just want to verify that the file was created, we can run the follow command: 

```docker
docker exec -it second_apache ls /root
```

This will display the result of the ls /root from the container. This command gets in container, display the file(s) under root and exit out of the container

```
user@node:~$ docker exec -it second_apache ls /root
hello
```

<br>

# Logging

Access to logs is necessary in software development. They provide feedback on how the application is running and most importantly they help with troubleshooting issues.

Let's see how we can see logs generated by an application running in a container.

We will use the command below to create a container running Jenkins.

```docker
docker run -dit --name busylogs -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts
```

When  Jenkins starts for the first time there's a generated password in the logs that is needed to login the first time we load the application. 
In order to get that password, we need to access the logs. The command below will help get the logs

```docker
docker logs busylogs
```

We can see the ouput of that command below

```
user@node:~$ docker logs busylogs

Running from: /usr/share/jenkins/jenkins.war
webroot: EnvVars.masterEnvVars.get("JENKINS_HOME")
2022-09-09 02:35:25.595+0000 [id=1]     INFO    winstone.Logger#logInternal: Beginning extraction from war file
2022-09-09 02:35:26.533+0000 [id=1]     WARNING o.e.j.s.handler.ContextHandler#setContextPath: Empty contextPath
2022-09-09 02:35:26.583+0000 [id=1]     INFO    org.eclipse.jetty.server.Server#doStart: jetty-10.0.11; built: 2022-06-21T21:12:44.640Z; git: d988aa016e0bb2de6fba84c1659049c72eae3e32; jvm 11.0.16.1+1
2022-09-09 02:35:26.799+0000 [id=1]     INFO    o.e.j.w.StandardDescriptorProcessor#visitServlet: NO JSP Support for /, did not find org.eclipse.jetty.jsp.JettyJspServlet
2022-09-09 02:35:26.850+0000 [id=1]     INFO    o.e.j.s.s.DefaultSessionIdManager#doStart: Session workerName=node0
2022-09-09 02:35:27.199+0000 [id=1]     INFO    hudson.WebAppMain#contextInitialized: Jenkins home directory: /var/jenkins_home found at: EnvVars.masterEnvVars.get("JENKINS_HOME")
2022-09-09 02:35:27.332+0000 [id=1]     INFO    o.e.j.s.handler.ContextHandler#doStart: Started w.@4d8286c4{Jenkins v2.361.1,/,file:///var/jenkins_home/war/,AVAILABLE}{/var/jenkins_home/war}
2022-09-09 02:35:27.347+0000 [id=1]     INFO    o.e.j.server.AbstractConnector#doStart: Started ServerConnector@e84a8e1{HTTP/1.1, (http/1.1)}{0.0.0.0:8080}
2022-09-09 02:35:27.363+0000 [id=1]     INFO    org.eclipse.jetty.server.Server#doStart: Started Server@32c8e539{STARTING}[10.0.11,sto=0] @2286ms
2022-09-09 02:35:27.365+0000 [id=24]    INFO    winstone.Logger#logInternal: Winstone Servlet Engine running: controlPort=disabled
2022-09-09 02:35:27.568+0000 [id=31]    INFO    jenkins.InitReactorRunner$1#onAttained: Started initialization
2022-09-09 02:35:27.590+0000 [id=30]    INFO    jenkins.InitReactorRunner$1#onAttained: Listed all plugins
2022-09-09 02:35:28.209+0000 [id=34]    INFO    jenkins.InitReactorRunner$1#onAttained: Prepared all plugins
2022-09-09 02:35:28.213+0000 [id=34]    INFO    jenkins.InitReactorRunner$1#onAttained: Started all plugins
2022-09-09 02:35:28.217+0000 [id=36]    INFO    jenkins.InitReactorRunner$1#onAttained: Augmented all extensions
2022-09-09 02:35:28.398+0000 [id=33]    INFO    jenkins.InitReactorRunner$1#onAttained: System config loaded
2022-09-09 02:35:28.398+0000 [id=30]    INFO    jenkins.InitReactorRunner$1#onAttained: System config adapted
2022-09-09 02:35:28.399+0000 [id=30]    INFO    jenkins.InitReactorRunner$1#onAttained: Loaded all jobs
2022-09-09 02:35:28.400+0000 [id=30]    INFO    jenkins.InitReactorRunner$1#onAttained: Configuration for all jobs updated
2022-09-09 02:35:28.421+0000 [id=53]    INFO    hudson.model.AsyncPeriodicWork#lambda$doRun$1: Started Download metadata
2022-09-09 02:35:28.427+0000 [id=53]    INFO    hudson.util.Retrier#start: Attempt #1 to do the action check updates server
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.codehaus.groovy.vmplugin.v7.Java7$1 (file:/var/jenkins_home/war/WEB-INF/lib/groovy-all-2.4.21.jar) to constructor java.lang.invoke.MethodHandles$Lookup(java.lang.Class,int)
WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.vmplugin.v7.Java7$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
2022-09-09 02:35:28.801+0000 [id=31]    INFO    jenkins.install.SetupWizard#init:

*************************************************************
*************************************************************
*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

f0c7ba8fc0244b0aa380febd46d7c737

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword

*************************************************************
*************************************************************
*************************************************************

2022-09-09 02:35:42.943+0000 [id=53]    INFO    h.m.DownloadService$Downloadable#load: Obtained the updated data file for hudson.tasks.Maven.MavenInstaller
2022-09-09 02:35:42.945+0000 [id=53]    INFO    hudson.util.Retrier#start: Performed the action check updates server successfully at the attempt #1
2022-09-09 02:35:42.946+0000 [id=53]    INFO    hudson.model.AsyncPeriodicWork#lambda$doRun$1: Finished Download metadata. 14,524 ms
```


As seen in the ouput above, the log is static. It is possible to display the logs as they are being printed. 

The command below (like the tail -f command in linux) display the live log lines as they are generated by the application

```docker
docker logs -f busylogs
```

In case we need to see the timestamp of each log, the command below is issued:

```docker
docker logs -t busylogs
```

Let's connect to the jenkins app on the browser. As Jenkins generate some logs we can view them in real time.
We issue the command below to display the log lines in real time with their timestamp:

```docker
docker logs -tf busylogs
```

<br>

# Conclusion

In this article we learned how to start, stop and remove a container. We also learned the **-dit** flags run the container in detached mode and provide a way to interact with a container already running. Instead of using the hash or ID generated after a container is created, we learned how to provide a user friendly name to a container. 
We know how to view containers regarless of their states. 

Since applications running in containers need to be available to the outside world, we learned how to provide a port to make the container accessible. Lastly we learned how to access a container that is alraedy running and to view logs generated in a container.